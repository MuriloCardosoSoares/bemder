warning: LF will be replaced by CRLF in bemder/exterior_api_new.py.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in bemder/interior_api.py.
The file will have its original line endings in your working directory
[1mdiff --git a/bemder/__pycache__/exterior_api_new.cpython-37.pyc b/bemder/__pycache__/exterior_api_new.cpython-37.pyc[m
[1mindex 41c3989..ca57749 100644[m
Binary files a/bemder/__pycache__/exterior_api_new.cpython-37.pyc and b/bemder/__pycache__/exterior_api_new.cpython-37.pyc differ
[1mdiff --git a/bemder/__pycache__/interior_api.cpython-37.pyc b/bemder/__pycache__/interior_api.cpython-37.pyc[m
[1mindex 3506070..5b2cb82 100644[m
Binary files a/bemder/__pycache__/interior_api.cpython-37.pyc and b/bemder/__pycache__/interior_api.cpython-37.pyc differ
[1mdiff --git a/bemder/__pycache__/porous.cpython-37.pyc b/bemder/__pycache__/porous.cpython-37.pyc[m
[1mindex 664399f..e6f0bfd 100644[m
Binary files a/bemder/__pycache__/porous.cpython-37.pyc and b/bemder/__pycache__/porous.cpython-37.pyc differ
[1mdiff --git a/bemder/exterior_api_new.py b/bemder/exterior_api_new.py[m
[1mindex 164571a..3488e55 100644[m
[1m--- a/bemder/exterior_api_new.py[m
[1m+++ b/bemder/exterior_api_new.py[m
[36m@@ -388,6 +388,275 @@[m [mclass ExteriorBEM:[m
             print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
         return p,u[m
     [m
[32m+[m[32m    def combined_direct_bemsolve(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Computes the bempp gridFunctions for the interior acoustic problem.[m
[32m+[m[41m        [m
[32m+[m[32m        Outputs:[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = grid_function for boundary pressure[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = grid_function for boundary velocity[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[41m        [m
[32m+[m[32m        p = {}[m
[32m+[m[32m        u ={}[m
[32m+[m[32m        # mu_fi = np.array([self.mu[i] for i in self.mu.keys()])[m
[32m+[m[32m        r0_fi = np.array([self.r0[i] for i in self.r0.keys()])[m
[32m+[m[32m        q_fi = np.array([self.q[i] for i in self.q.keys()])[m
[32m+[m[41m        [m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[41m            [m
[32m+[m
[32m+[m
[32m+[m[32m            f = self.f_range[fi] #Convert index to frequency[m
[32m+[m[32m            k = 2*np.pi*f/self.c0 # Calculate wave number[m
[32m+[m[41m            [m
[32m+[m[32m            # @bempp.api.real_callable(jit=False)[m
[32m+[m[32m            # def mu_fun_r(x,n,domain_index,result):[m
[32m+[m[32m            #     result[0]=np.real(mu_fi[domain_index-1,fi])[m
[32m+[m[41m                [m
[32m+[m[32m            # @bempp.api.real_callable(jit=False)[m
[32m+[m[32m            # def mu_fun_i(x,n,domain_index,result):[m
[32m+[m[32m            #     result[0]=np.imag(mu_fi[domain_index-1,fi])[m
[32m+[m
[32m+[m[32m#            @bempp.api.real_callable(jit=False)[m
[32m+[m[32m#            def v_data(x,n,domain_index,result):[m
[32m+[m[32m#                result[0]=0[m
[32m+[m[32m#                result[0] = self.v[domain_index][fi]*(n[0]-1)[m
[32m+[m[41m            [m
[32m+[m[32m            # mu_op_r = bempp.api.MultiplicationOperator(bempp.api.GridFunction(self.space,fun=mu_fun_r),self.space,self.space,self.space)[m
[32m+[m[32m            # mu_op_i = bempp.api.MultiplicationOperator(bempp.api.GridFunction(self.space,fun=mu_fun_i),self.space,self.space,self.space)[m
[32m+[m[41m        [m
[32m+[m[32m            identity = bempp.api.operators.boundary.sparse.identity([m
[32m+[m[32m                self.space, self.space, self.space)[m
[32m+[m[32m            # dlp = bempp.api.operators.boundary.helmholtz.double_layer([m
[32m+[m[32m                # self.space, self.space, self.space, k)[m
[32m+[m[32m            adlp = bempp.api.operators.boundary.helmholtz.adjoint_double_layer([m
[32m+[m[32m                self.space, self.space, self.space, k)[m
[32m+[m[32m            slp = bempp.api.operators.boundary.helmholtz.single_layer([m
[32m+[m[32m                self.space, self.space, self.space, k)[m
[32m+[m[41m            [m
[32m+[m[32m#            hyp = bempp.api.operators.boundary.helmholtz.hypersingular([m
[32m+[m[32m#                self.space, self.space, self.space, k)[m
[32m+[m[41m            [m
[32m+[m[32m            @bempp.api.complex_callable(jit=False)[m
[32m+[m[32m            def combined_data(r, n, domain_index, result):[m
[32m+[m[32m                # result[0] = 1j * k * np.exp(1j * k * (r[0]*self.r0[0][0]+r[1]*self.r0[0][1]+r[2]*self.r0[0][2]))*(n[0]*self.r0[0][0])+(n[1]*self.r0[0][1])+(n[2]*self.r0[0][2])[m
[32m+[m[32m                result[0] = 1j * k * np.exp(1j * k * r[0])*(n[0]-1)[m
[32m+[m
[32m+[m[32m                # for i in range(len(q_fi)):[m
[32m+[m[32m                    # pos =  np.dot(r,self.r0[i])/np.linalg.norm(self.r0[i])[m
[32m+[m[32m                    # result[0] +=  1j * k *np.exp(1j * k * pos) * np.dot(self.r0[i],n)/np.linalg.norm(self.r0[i])[m
[32m+[m
[32m+[m[41m                      [m
[32m+[m[41m                [m
[32m+[m[32m            monopole_fun = bempp.api.GridFunction(self.space, fun=combined_data)[m
[32m+[m[32m#            v_fun = bempp.api.GridFunction(self.space, fun=v_data)[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[32m            A = 0.5*identity + adlp - 1j*k*slp[m
[32m+[m[32m#            B = hyp + 1j*k*(0.5*identity - adlp)*(mu_op_r+1j*mu_op_i)[m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m            Ar = (monopole_fun)# + 1j*self.rho0*self.c0*v_fun)[m
[32m+[m[32m#            Br = (0.5*identity + adlp)*monopole_fun[m
[32m+[m[41m            [m
[32m+[m[32m            lhs = A[m
[32m+[m[32m            rhs = Ar[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[41m        [m
[32m+[m[32m            boundP, info = bempp.api.linalg.gmres(lhs, rhs, tol=1E-5)[m
[32m+[m[41m        [m
[32m+[m[32m            # boundU = 1j*(mu_op_r+1j*mu_op_i)*k*boundP + monopole_fun# + 1j*self.rho0*self.c0*v_fun[m
[32m+[m[41m            [m
[32m+[m[32m            p[fi] = boundP[m
[32m+[m[32m            # u[fi] = boundU[m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m            print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
[32m+[m[32m        return p[m
[32m+[m[41m    [m
[32m+[m[32m    def combined_direct_bemsolve_n(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Computes the bempp gridFunctions for the interior acoustic problem.[m
[32m+[m[41m        [m
[32m+[m[32m        Outputs:[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = grid_function for boundary pressure[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = grid_function for boundary velocity[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[41m        [m
[32m+[m[32m        p = {}[m
[32m+[m[32m        u ={}[m
[32m+[m[32m        # mu_fi = np.array([self.mu[i] for i in self.mu.keys()])[m
[32m+[m[32m        r0_fi = np.array([self.r0[i] for i in self.r0.keys()])[m
[32m+[m[32m        q_fi = np.array([self.q[i] for i in self.q.keys()])[m
[32m+[m[41m        [m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[41m            [m
[32m+[m
[32m+[m
[32m+[m[32m            f = self.f_range[fi] #Convert index to frequency[m
[32m+[m[32m            k = 2*np.pi*f/self.c0 # Calculate wave number[m
[32m+[m[41m            [m
[32m+[m[32m            # @bempp.api.real_callable(jit=False)[m
[32m+[m[32m            # def mu_fun_r(x,n,domain_index,result):[m
[32m+[m[32m            #     result[0]=np.real(mu_fi[domain_index-1,fi])[m
[32m+[m[41m                [m
[32m+[m[32m            # @bempp.api.real_callable(jit=False)[m
[32m+[m[32m            # def mu_fun_i(x,n,domain_index,result):[m
[32m+[m[32m            #     result[0]=np.imag(mu_fi[domain_index-1,fi])[m
[32m+[m
[32m+[m[32m#            @bempp.api.real_callable(jit=False)[m
[32m+[m[32m#            def v_data(x,n,domain_index,result):[m
[32m+[m[32m#                result[0]=0[m
[32m+[m[32m#                result[0] = self.v[domain_index][fi]*(n[0]-1)[m
[32m+[m[41m            [m
[32m+[m[32m            # mu_op_r = bempp.api.MultiplicationOperator(bempp.api.GridFunction(self.space,fun=mu_fun_r),self.space,self.space,self.space)[m
[32m+[m[32m            # mu_op_i = bempp.api.MultiplicationOperator(bempp.api.GridFunction(self.space,fun=mu_fun_i),self.space,self.space,self.space)[m
[32m+[m[41m        [m
[32m+[m[32m            identity = bempp.api.operators.boundary.sparse.identity([m
[32m+[m[32m                self.space, self.space, self.space)[m
[32m+[m[32m            dlp = bempp.api.operators.boundary.helmholtz.double_layer([m
[32m+[m[32m                self.space, self.space, self.space, k)[m
[32m+[m[32m            hyp = bempp.api.operators.boundary.helmholtz.hypersingular(self.space, self.space, self.space, k)[m
[32m+[m[32m            # slp = bempp.api.operators.boundary.helmholtz.single_layer([m
[32m+[m[32m                # self.space, self.space, self.space, k)[m
[32m+[m
[32m+[m[32m            @bempp.api.complex_callable(jit=False)[m
[32m+[m[32m            def combined_data(r, n, domain_index, result):[m
[32m+[m[32m                # result[0] = 1j * k * np.exp(1j * k * (r[0]*self.r0[0][0]+r[1]*self.r0[0][1]+r[2]*self.r0[0][2]))*(n[0]*self.r0[0][0])+(n[1]*self.r0[0][1])+(n[2]*self.r0[0][2])[m
[32m+[m[32m                result[0] = 1j * k * np.exp(1j * k * r[0])*(n[0]-1)[m
[32m+[m
[32m+[m[32m                # for i in range(len(q_fi)):[m
[32m+[m[32m                    # pos =  np.dot(r,self.r0[i])/np.linalg.norm(self.r0[i])[m
[32m+[m[32m                    # result[0] +=  1j * k *np.exp(1j * k * pos) * np.dot(self.r0[i],n)/np.linalg.norm(self.r0[i])[m
[32m+[m
[32m+[m[41m                      [m
[32m+[m[41m                [m
[32m+[m[32m            monopole_fun = bempp.api.GridFunction(self.space, fun=combined_data)[m
[32m+[m[32m#            v_fun = bempp.api.GridFunction(self.space, fun=v_data)[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[32m            A =  -hyp + 1j*k*(0.5*identity - dlp)[m
[32m+[m[32m#            B = hyp + 1j*k*(0.5*identity - adlp)*(mu_op_r+1j*mu_op_i)[m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m            Ar =-(monopole_fun)# + 1j*self.rho0*self.c0*v_fun)[m
[32m+[m[32m#            Br = (0.5*identity + adlp)*monopole_fun[m
[32m+[m[41m            [m
[32m+[m[32m            lhs = A[m
[32m+[m[32m            rhs = Ar[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[41m        [m
[32m+[m[32m            boundP, info = bempp.api.linalg.gmres(lhs, rhs, tol=1E-5)[m
[32m+[m[41m        [m
[32m+[m[32m            # boundU = 1j*(mu_op_r+1j*mu_op_i)*k*boundP + monopole_fun# + 1j*self.rho0*self.c0*v_fun[m
[32m+[m[41m            [m
[32m+[m[32m            p[fi] = boundP[m
[32m+[m[32m            # u[fi] = boundU[m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m            print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
[32m+[m[32m        return p[m
[32m+[m[41m    [m
[32m+[m[32m    def combined_direct_bemsolve_r(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Computes the bempp gridFunctions for the interior acoustic problem.[m
[32m+[m[41m        [m
[32m+[m[32m        Outputs:[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = grid_function for boundary pressure[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = grid_function for boundary velocity[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[41m        [m
[32m+[m[32m        p = {}[m
[32m+[m[32m        u ={}[m
[32m+[m[32m        mu_fi = np.array([self.mu[i] for i in self.mu.keys()])[m
[32m+[m[32m        r0_fi = np.array([self.r0[i] for i in self.r0.keys()])[m
[32m+[m[32m        q_fi = np.array([self.q[i] for i in self.q.keys()])[m
[32m+[m[41m        [m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[41m            [m
[32m+[m
[32m+[m
[32m+[m[32m            f = self.f_range[fi] #Convert index to frequency[m
[32m+[m[32m            k = 2*np.pi*f/self.c0 # Calculate wave number[m
[32m+[m[41m            [m
[32m+[m[32m            @bempp.api.real_callable(jit=False)[m
[32m+[m[32m            def mu_fun_r(x,n,domain_index,result):[m
[32m+[m[32m                result[0]=np.real(mu_fi[domain_index-1,fi])[m
[32m+[m[41m                [m
[32m+[m[32m            @bempp.api.real_callable(jit=False)[m
[32m+[m[32m            def mu_fun_i(x,n,domain_index,result):[m
[32m+[m[32m                result[0]=np.imag(mu_fi[domain_index-1,fi])[m
[32m+[m
[32m+[m[32m#            @bempp.api.real_callable(jit=False)[m
[32m+[m[32m#            def v_data(x,n,domain_index,result):[m
[32m+[m[32m#                result[0]=0[m
[32m+[m[32m#                result[0] = self.v[domain_index][fi]*(n[0]-1)[m
[32m+[m[41m            [m
[32m+[m[32m            mu_op_r = bempp.api.MultiplicationOperator(bempp.api.GridFunction(self.space,fun=mu_fun_r),self.space,self.space,self.space)[m
[32m+[m[32m            mu_op_i = bempp.api.MultiplicationOperator(bempp.api.GridFunction(self.space,fun=mu_fun_i),self.space,self.space,self.space)[m
[32m+[m[41m        [m
[32m+[m[32m            identity = bempp.api.operators.boundary.sparse.identity([m
[32m+[m[32m                self.space, self.space, self.space)[m
[32m+[m[32m            dlp = bempp.api.operators.boundary.helmholtz.double_layer([m
[32m+[m[32m                self.space, self.space, self.space, k)[m
[32m+[m[32m            adlp = bempp.api.operators.boundary.helmholtz.adjoint_double_layer([m
[32m+[m[32m                self.space, self.space, self.space, k)[m
[32m+[m[32m            hyp = bempp.api.operators.boundary.helmholtz.hypersingular(self.space, self.space, self.space, k)[m
[32m+[m[32m            slp = bempp.api.operators.boundary.helmholtz.single_layer([m
[32m+[m[32m                self.space, self.space, self.space, k)[m
[32m+[m
[32m+[m[32m            @bempp.api.complex_callable(jit=False)[m
[32m+[m[32m            def combined_data(r, n, domain_index, result):[m
[32m+[m[32m                # result[0] = 1j * k * np.exp(1j * k * (r[0]*self.r0[0][0]+r[1]*self.r0[0][1]+r[2]*self.r0[0][2]))*(n[0]*self.r0[0][0])+(n[1]*self.r0[0][1])+(n[2]*self.r0[0][2])[m
[32m+[m[32m                result[0] = 1j * k * np.exp(1j * k * r[0])*(n[0]-1) + 1j*k*mu_fi[domain_index-1,fi]*np.exp(1j * k * r[0])[m
[32m+[m
[32m+[m[32m                # for i in range(len(q_fi)):[m
[32m+[m[32m                    # pos =  np.dot(r,self.r0[i])/np.linalg.norm(self.r0[i])[m
[32m+[m[32m                    # result[0] +=  1j * k *np.exp(1j * k * pos) * np.dot(self.r0[i],n)/np.linalg.norm(self.r0[i])[m
[32m+[m
[32m+[m[41m                      [m
[32m+[m[41m                [m
[32m+[m[32m            monopole_fun = bempp.api.GridFunction(self.space, fun=combined_data)[m
[32m+[m[32m#            v_fun = bempp.api.GridFunction(self.space, fun=v_data)[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[32m            B =  -hyp + 1j*k*(0.5*identity - dlp)*(mu_op_r+1j*mu_op_i)[m
[32m+[m[32m            Al = (0.5*identity + adlp) -1j*k*(mu_op_r+1j*mu_op_i)*slp[m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m            Ar =-(monopole_fun)# + 1j*self.rho0*self.c0*v_fun)[m
[32m+[m[32m#            Br = (0.5*identity + adlp)*monopole_fun[m
[32m+[m[41m            [m
[32m+[m[32m            lhs = B + 1j*Al[m
[32m+[m[32m            rhs = Al*Ar[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[41m        [m
[32m+[m[32m            boundP, info = bempp.api.linalg.gmres(lhs, rhs, tol=1E-5)[m
[32m+[m[41m        [m
[32m+[m[32m            boundU = 1j*(mu_op_r+1j*mu_op_i)*k*boundP - monopole_fun[m
[32m+[m[41m            [m
[32m+[m[32m            p[fi] = boundP[m
[32m+[m[32m            u[fi] = boundU[m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m            print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
[32m+[m[32m        return p, u[m
     def monopole(self,fi,pts):[m
         [m
         pInc = np.zeros(pts.shape[0], dtype='complex128')[m
[36m@@ -396,8 +665,17 @@[m [mclass ExteriorBEM:[m
             pos = np.linalg.norm(pts-self.r0[i].reshape(1,3),axis=1)[m
             pInc += self.q[i]*np.exp(1j*(2*np.pi*self.f_range[fi]/self.c0)*pos)/(4*np.pi*pos)[m
             [m
[31m-        return pInc  [m
[32m+[m[32m        return pInc[m
     [m
[32m+[m[32m    def planewave(self,fi,pts):[m
[32m+[m[32m        pInc = np.zeros(pts.shape[0], dtype='complex128')[m
[32m+[m[41m        [m
[32m+[m[32m        for i in range(len(self.q)):[m[41m [m
[32m+[m[32m            # pos = np.dot(pts,self.r0[i])/np.linalg.norm(self.r0[fi])[m
[32m+[m[32m            pos = pts[:,0][m
[32m+[m[32m            pInc += self.q[i]*np.exp(1j*(2*np.pi*self.f_range[fi]/self.c0)*pos)[m
[32m+[m[41m            [m
[32m+[m[32m        return (pInc)[m
     def point_evaluate(self,points, boundP,boundU):[m
         [m
         """[m
[36m@@ -437,6 +715,157 @@[m [mclass ExteriorBEM:[m
             [m
         return  np.array([pT[i] for i in pT.keys()]).reshape(len(pT),len(points))[m
     [m
[32m+[m[32m    def combined_point_evaluate(self,points, boundP):[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[32m        Evaluates the solution (pressure) for a point.[m
[32m+[m[41m        [m
[32m+[m[32m        Inputs:[m
[32m+[m[32m            points = dict[0:numPoints] containing np arrays with receiver positions[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m        Output:[m
[32m+[m[41m            [m
[32m+[m[32m           pT =  Total Pressure Field[m
[32m+[m[41m           [m
[32m+[m[32m        """[m
[32m+[m[32m        pT = {}[m
[32m+[m[32m        pts = np.array([points[i] for i in points.keys()]).reshape(len(points),3)[m
[32m+[m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[32m            f = self.f_range[fi] #Convert index to frequency[m
[32m+[m[32m            k = 2*np.pi*f/self.c0[m
[32m+[m[41m                [m
[32m+[m[32m            slp_pot = bempp.api.operators.potential.helmholtz.single_layer([m
[32m+[m[32m                self.space, pts.T, k)[m
[32m+[m[32m            pScat =  -slp_pot.evaluate(boundP[fi])[m
[32m+[m[41m            [m
[32m+[m[32m            pInc = self.planewave(fi,pts)[m
[32m+[m[41m            [m
[32m+[m[32m            pT[fi] = pInc+pScat[m
[32m+[m
[32m+[m[32m            print(20*np.log10(np.abs(pT[fi])/2e-5))[m
[32m+[m[32m            print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
[32m+[m[41m            [m
[32m+[m[32m        return  np.array([pT[i] for i in pT.keys()]).reshape(len(pT),len(points))[m
[32m+[m[41m    [m
[32m+[m[32m    def combined_point_evaluate_n(self,points, boundP):[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[32m        Evaluates the solution (pressure) for a point.[m
[32m+[m[41m        [m
[32m+[m[32m        Inputs:[m
[32m+[m[32m            points = dict[0:numPoints] containing np arrays with receiver positions[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m        Output:[m
[32m+[m[41m            [m
[32m+[m[32m           pT =  Total Pressure Field[m
[32m+[m[41m           [m
[32m+[m[32m        """[m
[32m+[m[32m        pT = {}[m
[32m+[m[32m        pts = np.array([points[i] for i in points.keys()]).reshape(len(points),3)[m
[32m+[m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[32m            f = self.f_range[fi] #Convert index to frequency[m
[32m+[m[32m            k = 2*np.pi*f/self.c0[m
[32m+[m[41m                [m
[32m+[m[32m            # slp_pot = bempp.api.operators.potential.helmholtz.single_layer([m
[32m+[m[32m            #     self.space, pts.T, k)[m
[32m+[m[32m            dlp_pot = bempp.api.operators.potential.helmholtz.double_layer([m
[32m+[m[32m                self.space, pts.T, k)[m
[32m+[m[32m            pScat =  dlp_pot.evaluate(boundP[fi])# + 1j*k*slp_pot.evaluate(boundP[fi])[m
[32m+[m[41m            [m
[32m+[m[32m            pInc = self.planewave(fi,pts)[m
[32m+[m[41m            [m
[32m+[m[32m            pT[fi] = pInc+pScat[m
[32m+[m
[32m+[m[32m            print(20*np.log10(np.abs(pT[fi])/2e-5))[m
[32m+[m[32m            print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
[32m+[m[41m            [m
[32m+[m[32m        return  np.array([pT[i] for i in pT.keys()]).reshape(len(pT),len(points))[m
[32m+[m
[32m+[m[32m    def scattered_point_evaluate_n(self,points, boundP):[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[32m        Evaluates the solution (pressure) for a point.[m
[32m+[m[41m        [m
[32m+[m[32m        Inputs:[m
[32m+[m[32m            points = dict[0:numPoints] containing np arrays with receiver positions[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m        Output:[m
[32m+[m[41m            [m
[32m+[m[32m           pT =  Total Pressure Field[m
[32m+[m[41m           [m
[32m+[m[32m        """[m
[32m+[m[32m        pT = {}[m
[32m+[m[32m        pts = np.array([points[i] for i in points.keys()]).reshape(len(points),3)[m
[32m+[m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[32m            f = self.f_range[fi] #Convert index to frequency[m
[32m+[m[32m            k = 2*np.pi*f/self.c0[m
[32m+[m[41m                [m
[32m+[m[32m            # slp_pot = bempp.api.operators.potential.helmholtz.single_layer([m
[32m+[m[32m            #     self.space, pts.T, k)[m
[32m+[m[32m            dlp_pot = bempp.api.operators.potential.helmholtz.double_layer([m
[32m+[m[32m                self.space, pts.T, k)[m
[32m+[m[32m            pScat =  dlp_pot.evaluate(boundP[fi])# + 1j*k*slp_pot.evaluate(boundP[fi])[m
[32m+[m[41m                        [m
[32m+[m[32m            pT[fi] = pScat[m
[32m+[m
[32m+[m[32m            print(20*np.log10(np.abs(pT[fi])/2e-5))[m
[32m+[m[32m            print('{} / {}'.format(fi+1,np.size(self.f_range)))[m
[32m+[m[41m            [m
[32m+[m[32m        return  np.array([pT[i] for i in pT.keys()]).reshape(len(pT),len(points))[m
[32m+[m[41m    [m
[32m+[m[32m    def combined_point_evaluate_r(self,points, boundP,boundU):[m
[32m+[m[41m        [m
[32m+[m[32m        """[m
[32m+[m[32m        Evaluates the solution (pressure) for a point.[m
[32m+[m[41m        [m
[32m+[m[32m        Inputs:[m
[32m+[m[32m            points = dict[0:numPoints] containing np arrays with receiver positions[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m            boundP = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m            boundU = output from bemsolve()[m
[32m+[m[41m            [m
[32m+[m[32m        Output:[m
[32m+[m[41m            [m
[32m+[m[32m           pT =  Total Pressure Field[m
[32m+[m[41m           [m
[32m+[m[32m        """[m
[32m+[m[32m        pT = {}[m
[32m+[m[32m        pts = np.array([points[i] for i in points.keys()]).reshape(len(points),3)[m
[32m+[m
[32m+[m[32m        for fi in range(np.size(self.f_range)):[m
[32m+[m[32m 